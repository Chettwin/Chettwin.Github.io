<!DOCTYPE html>
<html lang="en">




<head><meta name="generator" content="Hexo 3.8.0">

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  
      <title>Search - Hexo</title>
  

  
  
  <meta name="description" content="">
  <meta name="author" content="John Doe">

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- load loadjs.js -->
  <script src="/libs/loadjs/dist/loadjs.min.js"></script>

<link rel="stylesheet" href="/libs/animate.css/animate.min.css">
  <!-- load lightgallery -->
<link rel="stylesheet" href="/css/lightgallery.css">
<link rel="stylesheet" href="/libs/noty/lib/noty.css">
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
  






    <link rel="stylesheet" href="/css/taurus.css">
    
        <link rel="stylesheet" href="/css/scheme-taurus/animations.css">
    


<link rel="stylesheet" href="/.css">

  <!-- load font awesome 5 -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
  </script>
  <!-- load mathjax -->
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax//libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <!-- load js-cookie -->
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
    <script src="/js/social-share.min.js"></script>
    <script src="/js/theme.js"></script>

  <!-- include cookie.js -->
  
  

  <!-- include comment system code -->
  
    <script src="//cdn1.lncld.net/static/js/3.6.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/favicon.png">
</head>
<body style="display: flex; flex-direction: column; min-height: 100vh;">

 

<header id="header" class="header">
	<div class="header-title">
		
		<div class="header-logo">
			<a href="/">
				<img src="/images/theme-icon.svg">
			</a>
		</div>
		<div class="header-text">
			<h1>
				<a href="/">Hexo</a>
			</h1>
			<subtitle>
				
			</subtitle>
		</div>
		
	</div>
	<div id="header-nav">
		



<nav id="nav">
	
	
	
	<div class="nav-item" id="nav-item-archive">
		
				<div class="nav-icon">
				
			<a href="/archives/" title="Archives">
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id="nav-item-search">
		
		<div class="nav-icon active_dot">
		
			<a href="/search/" title="Search">
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id="nav-item-more">
		<div class="nav-icon">
				<a href="#" onclick="onClickMenuIcon(event);" ontouchstart="onClickMenuIcon(event);">
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id="nav-more-menu-close" onclick="onClickNavMenuClose(event);" ontouchstart="onClickNavMenuClose(event);"></i>
		
		
	</div>
	</div>
</nav>

	</div>
</header>

 




  <!-- Primary Page Layout
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <div style="flex: 1;">
      <style>
    body {
        background-color: white;
    }
</style>
<div class="search-container">
	<input type="text" id="search-form">

	<ul class="cat-list">
		
	</ul>

	<div class="archive-cards">
			<div class="Card-archive" style="display:none">
				<div class="Card-body">
					<h3 class="Card-title">
						<a>
						</a>
					</h3>
					<div class="Card-meta">
						<ul>
							<li><i class="fa fa-calendar"></i> <span class="Card-date"></span></li>
						</ul>
					</div>
				</div>
			</div>
		</div>
</div>

<script src="/libs/fuse.js/dist/fuse.min.js"></script>
<script>
	var options = {
		shouldSort: true,
		threshold: 0.4,
		tokenize: true,
		location: 0,
		distance: 100,
		maxPatternLength: 32,
		minMatchCharLength: 2,
		keys: [
			"title",
			"author",
			"tags"
		]
	};
	var s = '[{"title":"数据结构复习要点","date":"2018-12-25T09:06:48.000Z","content":"计算机程序由算法与数据结构组成，DS的在计算机科学专业的学习中显得尤为重要。\n一、绪论&nbsp;&nbsp;1.数据结构的定义&nbsp;&nbsp;&nbsp;&nbsp;数据结构，是相互之间存在一种或多种关系的数据元素的集合。结构，抽象到数据层面，就是数据元素之间的关系。不同于建筑结构等实体结构。\n&nbsp;&nbsp;2.数据逻辑结构的分类&nbsp;&nbsp;&nbsp;&nbsp;根据数据元素之间的关系，可以将基本的数据结构分为四类：集合、线性结构、树形结构、图状结构网状结构。\n\n线性结构：每个元素之间存在先后顺序，前后两个元素之间具有前驱后继关系。\n树形结构：一对多的关系\n图状结构：每两个元素之间可能存在关系，多对多关系。\n\n&nbsp;&nbsp;3.数据存储结构的分类&nbsp;&nbsp;&nbsp;&nbsp;数据的存储结构分为两种：顺序结构和链式结构。\n二、线性表&nbsp;&nbsp;1.线性表的定义&nbsp;&nbsp;&nbsp;&nbsp;线性表是n个数据元素的有限序列。通常表示形式为：L=(a1,a2,…,a,…,an)，n=0为空表。其中的每个数据元素具有相同的数据类型。只有唯一的第一和最后一个元素，除第一个元素外，每个元素有且只有一个前驱，除最后一个元素外，每个元素有且只有一个后继。\n&nbsp;&nbsp;2.堆栈&nbsp;&nbsp;&nbsp;&nbsp;具有一定操作约束的线性表，只在一端(栈顶)做插入删除操作。具有后入先出的性质，应用举例：中缀转后缀表达式。有两种实现方案：数组与链表。\n\n数组表示：1234struct SNode&#123;    ElementType Data[MaxSize];    int top;  指向栈顶的位置&#125;S;\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何改造这个数组，让一个数组能实现两个堆栈？12345struct Stack&#123;    ElementType Data[MaxSize];    int top1;  第一个栈栈顶位置，起始于数组开始的位置    int top2;  第二个栈栈顶位置，起始于数组末端&#125;S;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使两个栈分别从数组两端向中间生长，当两个栈顶指针相遇时，则栈满。\n\n链表表示：插入删除操作只能在栈顶进行，top应指向表头。1234567891011121314151617181920212223242526272829303132333435363738394041424344typedef struct SNode *PtrToSNode;struct SNode &#123;    ElementType Data;    PtrToSNode Next;&#125;;typedef PtrToSNode Stack; Stack CreateStack( ) &#123; * 构建一个堆栈的头结点，返回该结点指针 *    Stack S;     S = (Stack)malloc(sizeof(struct SNode));    S-&gt;Next = NULL;    return S;&#125; bool Push( Stack S, ElementType X )&#123; * 将元素X压入堆栈S *    PtrToSNode TmpCell;     TmpCell = (PtrToSNode)malloc(sizeof(struct SNode));    TmpCell-&gt;Data = X;    TmpCell-&gt;Next = S-&gt;Next;    S-&gt;Next = TmpCell;    return true;&#125; ElementType Pop( Stack S )  &#123; * 删除并返回堆栈S的栈顶元素 *    PtrToSNode FirstCell;    ElementType TopElem;     if( IsEmpty(S) ) &#123;        printf(&quot;堆栈空&quot;);         return ERROR;    &#125;    else &#123;        FirstCell = S-&gt;Next;         TopElem = FirstCell-&gt;Data;        S-&gt;Next = FirstCell-&gt;Next;        free(FirstCell);        return TopElem;    &#125;&#125;\n\n\n&nbsp;&nbsp;3.队列&nbsp;&nbsp;&nbsp;&nbsp;具有一定操作约束的线性表，只能在一端插入，而在另一端删除。具有先进先出的性质。\n\n数组表示：循环队列：为了防止队列空满无法区分，采用余下一个位置不使用的方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051typedef int Position;struct QNode &#123;    ElementType *Data;     * 存储元素的数组 *    Position Front, Rear;  * 队列的头、尾指针 *    int MaxSize;           * 队列最大容量 *&#125;;typedef struct QNode *Queue; Queue CreateQueue( int MaxSize )&#123;    Queue Q = (Queue)malloc(sizeof(struct QNode));    Q-&gt;Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));    Q-&gt;Front = Q-&gt;Rear = 0;    Q-&gt;MaxSize = MaxSize;    return Q;&#125; bool IsFull( Queue Q )&#123;    return ((Q-&gt;Rear+1)%Q-&gt;MaxSize == Q-&gt;Front);&#125; bool AddQ( Queue Q, ElementType X )&#123;    if ( IsFull(Q) ) &#123;        printf(&quot;队列满&quot;);        return false;    &#125;    else &#123;        Q-&gt;Rear = (Q-&gt;Rear+1)%Q-&gt;MaxSize;        Q-&gt;Data[Q-&gt;Rear] = X;        return true;    &#125;&#125; bool IsEmpty( Queue Q )&#123;    return (Q-&gt;Front == Q-&gt;Rear);&#125; ElementType DeleteQ( Queue Q )&#123;    if ( IsEmpty(Q) ) &#123;         printf(&quot;队列空&quot;);        return ERROR;    &#125;    else  &#123;        Q-&gt;Front =(Q-&gt;Front+1)%Q-&gt;MaxSize;        return  Q-&gt;Data[Q-&gt;Front];    &#125;&#125;\n\n链表表示：rear应指向链表的尾，front应指向链表的头。因为尾部不可做删除操作，因为单向链表找不到前一个节点的地址。\n123456789101112131415161718192021222324252627282930313233343536373839typedef struct Node *PtrToNode;struct Node &#123; * 队列中的结点 *    ElementType Data;    PtrToNode Next;&#125;;typedef PtrToNode Position; struct QNode &#123;    Position Front, Rear;  * 队列的头、尾指针 *    int MaxSize;           * 队列最大容量 *&#125;;typedef struct QNode *Queue; bool IsEmpty( Queue Q )&#123;    return ( Q-&gt;Front == NULL);&#125; ElementType DeleteQ( Queue Q )&#123;    Position FrontCell;     ElementType FrontElem;         if  ( IsEmpty(Q) ) &#123;        printf(&quot;队列空&quot;);        return ERROR;    &#125;    else &#123;        FrontCell = Q-&gt;Front;        if ( Q-&gt;Front == Q-&gt;Rear ) * 若队列只有一个元素 *            Q-&gt;Front = Q-&gt;Rear = NULL; * 删除后队列置为空 *        else                                 Q-&gt;Front = Q-&gt;Front-&gt;Next;        FrontElem = FrontCell-&gt;Data;         free( FrontCell );  * 释放被删除结点空间  *        return  FrontElem;    &#125;&#125;\n\n\n三、树&nbsp;&nbsp;1.二叉树&nbsp;&nbsp;&nbsp;&nbsp;二叉树的遍历有两种方法：递归与非递归。一个节点在遍历的时候会经过三次，第一次经过便访问则为先序遍历，第二次经过并访问为中序，最后一次经过并访问为后序遍历。\n\n递归遍历：递归遍历代码中的三次经过很明显能找到，直接在相应位置加入visit函数即可。代码如下：\n123456789101112131415161718192021222324252627void InorderTraversal( BinTree BT )&#123;    if( BT ) &#123;        InorderTraversal( BT-&gt;Left );        * 此处假设对BT结点的访问就是打印数据 *        printf(&quot;%d &quot;, BT-&gt;Data); * 假设数据为整型 *        InorderTraversal( BT-&gt;Right );    &#125;&#125; void PreorderTraversal( BinTree BT )&#123;    if( BT ) &#123;        printf(&quot;%d &quot;, BT-&gt;Data );        PreorderTraversal( BT-&gt;Left );        PreorderTraversal( BT-&gt;Right );    &#125;&#125; void PostorderTraversal( BinTree BT )&#123;    if( BT ) &#123;        PostorderTraversal( BT-&gt;Left );        PostorderTraversal( BT-&gt;Right );        printf(&quot;%d &quot;, BT-&gt;Data);    &#125;&#125;\n\n非递归遍历：借助到堆栈实现。中序遍历的算法为：从一个节点一直向左找到最左节点，且将经过的所有节点压栈；如果栈非空，则pop栈顶元素并访问；按其右指针再去中序遍历其右子树。先序遍历只需要将访问函数放在第一步，也就是压栈的时候，即可实现。算法实现如下：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657中序遍历void InOrderTraversal(bin_tree T)&#123;    Stack s = createStack();    while(T || !isEmpty(s))    &#123;        从一个节点一直找最左节点        while(T)        &#123;            push(T,s);            T = T-&gt;left;        &#125;        栈非空        if(!isEmpty(s))        &#123;            T = pop(s);            visit(T);            遍历其右子树            T = T-&gt;right;           &#125;    &#125;&#125;添加访问次数属性就破坏了树结点的结构了吧，将树全部先压入栈的方式又需要很大的栈，可以考虑在pop之前先看看当前的栈顶结点有没右儿子如果有右儿子的话，将右儿子压栈，对右子树进行处理void last_search(bin_tree t)&#123;    ptr_stack s = create_stack();    bin_tree last_r = NULL;    while (t || !is_empty(s))    &#123;        while (t)        &#123;            push(s, t);            t = t-&gt;left;        &#125;        if (!is_empty(s))        &#123;            思路，由于是后序，所以如果当前要弹出的结点的右儿子不为空，且其右儿子不是上一次弹出的            要对右儿子先进行处理            if (top(s)-&gt;right &amp;&amp; top(s)-&gt;right != last_r)            &#123;                t = top(s)-&gt;right;            &#125;            else            &#123;                t = pop(s);                last_r = t;                printf(&quot;%d &quot;, t-&gt;data);                t = NULL;            &#125;        &#125;    &#125;    free(s);&#125;\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;真正的难点在于如何用堆栈实现非递归后序遍历。如果仅仅是改变访问函数的位置仿佛做不到。得引入一个指针变量，用于记录上一次访问的节点。可将一个节点的右子树分为三种情况：无右子树；有右子树但并未访问；有右子树且访问过。无右子树时需要访问该节点(即将其pop()出来);有右子树且上一次访问的节点是该节点右子树的根节点时，则说明是第三种情况，接下来需要访问该节点;有右子树且上一次访问的节点不是该节点的右子树的根节点时，为第二种情况，接下来需要变量其右子树。代码已在上面提供。\n\n层序遍历：二叉树遍历的本质是将二维的树状结构线性化，最核心的问题是如何记住一个节点的左右儿子。得利用到队列，算法描述：从根节点开始，将根节点入队，然后执行循环：出队，访问，左右儿子入队。思路还是很清晰的，代码如下：12345678910111213141516void LevelorderTraversal ( BinTree BT )&#123;     Queue Q;     BinTree T;     if ( !BT ) return; * 若是空树则直接返回 *         Q = CreatQueue(); * 创建空队列Q *    AddQ( Q, BT );    while ( !IsEmpty(Q) ) &#123;        T = DeleteQ( Q );        printf(&quot;%d &quot;, T-&gt;Data); * 访问取出队列的结点 *        if ( T-&gt;Left )   AddQ( Q, T-&gt;Left );        if ( T-&gt;Right )  AddQ( Q, T-&gt;Right );    &#125;&#125;\n\n","tags":[],"path":"2018/12/25/DataStructure/","external_link":""},{"title":"Hello World","date":"2018-12-17T04:17:49.831Z","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new My New Post\nMore info: Writing\nRun server1$ hexo server\nMore info: Server\nGenerate static files1$ hexo generate\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\nMore info: Deployment\n","tags":[],"path":"2018/12/17/hello-world/","external_link":""},{"title":"javaScript DOM方法","date":"2018-12-17T05:53:24.000Z","content":"  &nbsp;&nbsp;最近想自己从头到尾写一个web项目，大致了解一下web项目从前到后的开发所涉及到的一些技术领域。前端主要是html，css与js。js的任务是让网页有动态效果，其中很重要的技术方法便是DOM方法。\nDOM介绍  &nbsp;&nbsp;当将一个网页加载到web浏览器中时，DOM就在幕后悄然产生，它的作用是将网页文档转换成一个文档对象。这个文档对象具有树的结构，网页中的每个标签、文本、标签属性都是这个对象树中的节点。而js就可以根据DOM方法对树中的一些节点进行操作。这就是DOM。\nDOM方法\ngetElementById(String Id):此方法返回一个独一无二的具有id属性值为指定的id的元素，返回类型是一个对象。\ngetElementByTagName(String tag):此方法返回一个对象数组。示例代码如下：\n1document.getElementByTagName(&quot;li&quot;);\n&nbsp;&nbsp;这个调用将返回一个对象数组，可以利用length属性查出元素个数。\n\ngetElementByClassName(String class):返回值与上面类似，都是一个具有相同类名的元素的数组。值得注意的是，clas参数可包含多个类名，只要在参数中用空格将类名分隔开即可。例如：\n1document.getElementByClass(&quot;important sale&quot;);\n&nbsp;&nbsp;即使在元素的class属性中，类名顺序是”sale important”，也会匹配。不仅类名的实际顺序不重要，就算元素还带有更多的类名也没有关系。\n\ngetAttribute(String attribute):只能通过元素节点对象调用，如果元素对象没有”attribute”属性，则返回null，否则返回属性值。示例:\n12var para = document.getElementById(&quot;photo&quot;)alert(para.getAttribute(&quot;src&quot;));\n\nsetAttribute(String attribute,String value):设置元素的属性值，若原先属性值不存在会先创建这个属性，然后设置它的值。\n12var para = document.getElementById(&quot;photo&quot;)alert(para.setAttribute(&quot;src&quot;,&quot;photonum1.jpg&quot;));\n\n","tags":[],"path":"2018/12/17/Js DOM/","external_link":""},{"title":"操作系统复习要点","date":"2018-12-23T02:14:58.000Z","content":"进程(process)VS线程(thread)  &nbsp;&nbsp;要理解进程与线程的区别，如果弄清楚了进程与线程二者的构成的话，就会很容易地明白二者的不同。\n\n进程：包含线程、内存、文件网络句柄(handle)。\n线程：一个进程包含多个线程，线程之间共享os为该进程分配的一块内存。\n内存：由os分配，每个进程os都为其分配一个固定大小的内存（寻址空间）,这个内存是逻辑内存，并非实际的物理内存。例如：32位机器给每个进程分配的内存大小是2^32字节，即4G的空间。并且，每个进程间的内存相互独立，想想如果不独立的话，一个进程就可以改动其他进程所指的内存空间，这是非常不安全的。这还涉及到进程间相互通信的问题。内存的内部组成如下图所示：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n文件网络句柄：与内存不同，这些资源是各个进程间共享的，不属于固定某一个进程独有。任两个进程间都可以访问同一个文件，或者去抢用同一个网络的端口。\n\n\n线程：包含调用堆栈、程序计数器(PC)、ThreadLocalStorage。\n调用堆栈：堆与栈是不同的数据结构，其实只有调用栈，堆在这个短语中无实际意义，只是一种习惯称呼。线程的入口main函数会把每次函数的调用信息压入栈中，包括参数、返回地址与局部变量等信息。\n程序计数器：ProgramCounter，存放线程应执行的当前或者下一条指令指针，该指针指向的地址是进程所占据的内存中的一个地址。\nTLS：每个线程的独立内存，在这里分配一些变量，这些变量是线程独有的数据。&nbsp;&nbsp;P.S:大多数计算机都是存储程序型的，即运行时的数据与代码存储在同一段内存当中，这也会导致常见的漏洞，如：缓冲区溢出–运行产生的数据超出原分配的内存大小，以致于影响到代码区域，黑客可以通过这种方式从程序外部植入代码。\n\n\n\n&nbsp;&nbsp;在看完二者的组成之后，区别也就显而易见了：一个程序运行时，就会在操作系统中产生一个进程，并且os会未其分配一块固定大小的内存（大小由os的决定）,进程只是一个容器，其中真正运行的是一个个线程。\n存储设备  &nbsp;&nbsp;计算机存储设备包含四个层次：硬盘(磁能)、内存(电能)、缓存与寄存器。速度由慢到快，价格由便宜到高昂，离cpu由远及近。缓存为cpu与内存间的比内存更快的存储设备，一般有多级缓存。寄存器为cpu内部的存储设备，用于存储下一条要操作的指令等。\n寻址  &nbsp;&nbsp;在程序运行时，经常会涉及到操作系统寻址的过程。即将数据从实际的内存单元读入到寄存器的过程。对于32位系统，每个进程可寻址的空间为2^32字节，32位cpu可一次性处理4个字节的指令。64位系统则可寻址空间位2^64字节，64位cpu可一次性处理8个字节的指令。  &nbsp;&nbsp;比如下图所示的指令，则操作系统在对p指向的内存地址寻址时做出以下动作：先找到指针所指向的进程内的逻辑内存，再映射到实际的内存上，若映射到的是虚拟内存(内存交换区)，则从磁盘上读出其所在的页进入物理内存中。之后再读入寄存器中。  \n","tags":[],"path":"2018/12/23/operatingSystem/","external_link":""}]';

	s = s.replace(/\\n/g, "\\n")
               .replace(/\\'/g, "\\'")
               .replace(/\\"/g, '\\"')
               .replace(/\\&/g, "\\&")
               .replace(/\\r/g, "\\r")
               .replace(/\\t/g, "\\t")
               .replace(/\\b/g, "\\b")
               .replace(/\\f/g, "\\f")

// remove non-printable and other non-valid JSON chars
	s = s.replace(/[\u0000-\u0019]+/g,"");
	var list = JSON.parse(s);
	var fuse = new Fuse(list, options);
	var el = document.getElementById('search-form');
	var newBox = $('.Card-archive').first().clone();
	el.oninput = function(event){
		var searchText = el.value;
		var result = fuse.search(searchText);
		$('.archive-cards .Card-archive').remove();
		for(var i in result){
			var anotherBox = newBox.clone();
			var dateStr = new Date(result[i].date);
			anotherBox.css('display','flex');
			var url = "";
			if(result[i].external_link !== ""){
				url = result[i].external_link;
			}else{
				url = '/' + result[i].path;
			}

			anotherBox.find('.Card-title a').text(result[i].title).attr('href', url);
			anotherBox.find('.Card-date').text(dateStr.toDateString());
			anotherBox.appendTo('.archive-cards');
		}
	}
</script>

<div class="tagcloud-container">
<div class="tag-cloud">
	
</div>
</div>

  </div>

  

<footer id="footer">
    <div class="footer-copyright">
        <div>
            <p> Copyright by <a href="">John Doe </a> @ 2018</p>
            <p>Designed by: <i class="fas fa-paint-brush"></i> <a href="https://moober.cn">Moober</a> and <i class="fas fa-graduation-cap"></i> <a href="https://qutang.github.io">Qu Tang</a> &bull; Theme: <a href="https://qutang.github.io/cutie/">Cutie 2.1.3-Taurus</a> &bull; Powered by <a href="http://hexo.io">Hexo.</a></p>
        </div>
    </div>
    
    <div class="footer-social">
        
    </div>
</footer>

  <br>

  <div id="footer-nav" class='footer-nav'>
		



<nav id="nav">
	
	
	
	<div class="nav-item" id="nav-item-archive">
		
				<div class="nav-icon">
				
			<a href="/archives/" title="Archives">
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id="nav-item-search">
		
		<div class="nav-icon active_dot">
		
			<a href="/search/" title="Search">
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id="nav-item-more">
		<div class="nav-icon">
				<a href="#" onclick="onClickMenuIcon(event);" ontouchstart="onClickMenuIcon(event);">
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id="nav-more-menu-close" onclick="onClickNavMenuClose(event);" ontouchstart="onClickNavMenuClose(event);"></i>
		
		
	</div>
	</div>
</nav>

	</div>

  



    







    <script src="/js/lightgallery.min.js"></script>
<script src="/js/lg-zoom.min.js"></script>
<script type="text/javascript">
    $(document).ready(function() {
        $("#lightgallery").lightGallery(); 
        $(".article-content img").each(function(){
            console.log($(this).attr('src'))
            $(this).attr('data-src', $(this).attr('src')).lightGallery({
                selector: 'this'
            })
        });
    });
</script>






<script type="text/javascript">

  
</script>



<!-- <script src="/js/post.js"></script> -->

<script src="/js/headroom.min.js"></script>

<script data-no-instant="" type="text/javascript">

initHeadroom();

changeLayoutOnTouchScreen();

// 
</script>


<!-- End Document
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
</body>
</html>
